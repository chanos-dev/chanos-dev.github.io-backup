I"G<h2 id="c-garbage-collector-1"><center>[C#] Garbage Collector 1</center></h2>

<hr />

<p>닷넷의 가비지 컬렉터(이하 GC)을 살펴보기 전 GC가 없는 C/C++는 메모리 관리가 어떻게 되고 있는지 살펴보자.</p>

<p>C/C++ 환경에서의 메모리 할당/해제는 프로그래머의 몫으로, 힙에 자유메모리 블록을 런타임 라이브러리가 유지함으로써 관리되었다.</p>

<p>런타임 라이브러리는 힙 상에서 사용 가능한 메모리 블럭을 리스트로 유지하며, 메모리의 할당(new, malloc)이 있을 경우 해당 리스트에서 요청된 크기의 메모리 검색하여 찾으며 메모리가 해제(delete, free)되면 할당된 메모리는 다시 사용 가능한 메모리 리스트에 삽입된다.</p>

<p>C/C++의 메모리 관리 방식은 메모리 할당에 소요되는 시간이 상대적으로 길다. 메모리 할당/해제가 반복적으로 일어남에 따라 힙의 메모리 사용 패턴은 조각나기 쉽고 조각난 메모리는 메모리 할당 시 메모리 블록을 검색해야 하는 오버헤드를 갖기 때문이다.</p>

<p>메모리 해제 또한 오버헤드를 갖게 되는데, 메모리가 해제 될 때 인접한 자유 메모리 블록을 검사하여, 존재한다면 메모리 블럭을 병합하여 보다 큰 메모리 블록으로 만들어야하기 떄문이다.</p>

<p>다음 그림은 C/C++에서의 메모리 할당/해제 과정을 위 설명의 과정대로 표시한 그림이다.</p>

<p><a href="http://localhost:4000/images/posts/2021-04-20/gc1.png"><img src="http://localhost:4000/images/posts/2021-04-20/gc1.png" alt="gc1" /></a></p>

<hr />

<blockquote>
  <p><b> C# Garbage Collector 기본 작동 방식 </b> 🚙</p>
</blockquote>

<p>닷넷의 GC의 작동 방식은 선형 메모리 할당과 사용하지 않는 메모리 블록을 찾아 제거하는 형태로 이루어 진다.</p>

<hr />

<h2 id="reference">Reference</h2>

<p><a href="http://www.simpleisbest.net/post/2011/04/01/Review-NET-Garbage-Collection.aspx">가비지 컬렉션 다시 보기 Part I</a></p>
:ET